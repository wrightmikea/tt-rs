<!-- 
Generated by Proact for: Unknown Project
Generated at: 2025-11-27 10:43:50
-->

# AI Coding Agent Development Process Guidelines

This document provides explicit guidelines to be proactively followed by AI coding agents (Claude Code, Gemini CLI, opencode, Codex, etc.) during development tasks. Adherence ensures consistency, quality, maintainability, and continual improvement in codebases.

---

## 1. Process-Oriented Workflow

When a **checkpoint** is requested by the developer, execute the following sequence rigorously:

### a. Run and Fix Failing Tests
- Execute all available tests (unit, functional, integration).
- Identify failing tests and systematically debug and correct them.
- Confirm all tests pass post-fix.

### b. Fix Linting Issues
- Run appropriate linters for the project language (e.g., `clippy` for Rust, `eslint` for JavaScript).
- Resolve all warnings and errors, prioritizing idiomatic and efficient code solutions.
- Re-run linters to ensure clean results.

### c. Format Source Code
- Use standard formatting tools (e.g., `rustfmt`, `prettier`, `black`) to format all source files consistently.
- Ensure no formatting warnings or changes remain pending.

### d. Update Documentation
- Review affected documentation.
- Update comments, README files, and other documentation to reflect all code changes accurately.
- Include meaningful descriptions, usage examples, and doc tests as appropriate.

### e. Manage Git Status
- Run `git status` to identify changes.
- Categorize each file:
  - Stage for commit (`git add`) if relevant to the logical checkpoint.
  - Ignore/untrack irrelevant or temporary files via `.gitignore`.
  - Delete or move irrelevant files into an explicitly `.gitignored` folder when appropriate.
- Clearly communicate the rationale for each decision in the commit message or separate notes.

### f. Git Operations
- Stage changes with `git add`.
- Create a logical commit with a clear, descriptive message summarizing the checkpoint scope.
- Push the commit immediately (`git push`) to the remote repository, ensuring incremental backups and availability for testing and review on other systems.

---
## 2. Quality-Oriented Development

Ensure all generated code adheres strictly to the following quality standards:

### Documentation
- Clearly document all code modules, functions, and key logic blocks.
- Ensure compatibility with automated documentation generation tools (`cargo doc`, `Sphinx`, `JSDoc`, etc.).
- Write and maintain accurate, relevant doc tests within code comments to demonstrate correct usage.

### Testing
- Include unit tests for individual functions, validating core logic and handling edge cases.
- Provide functional tests verifying code behavior meets defined requirements and user stories.
- Integrate code modules through comprehensive integration tests confirming interoperability and end-to-end correctness.
- For Rust/WASM projects: Write tests in Rust, not Python. Use `wasm-bindgen-test` for WASM-specific tests.
- Explicitly defer more advanced testing (stress, load, benchmarks, fuzz testing) until explicitly requested by the developer.

### Tech Debt Avoidance

**File Size Limits**:
- Keep source files under 500 lines (prefer 200-300 lines)
- Split large files into logical modules
- If a file exceeds 500 lines, refactor immediately

**TODO Comments**:
- Limit to 3 TODO comments per file maximum
- Address TODOs within 2 development sessions
- Convert persistent TODOs to GitHub issues
- Never commit code with FIXMEs - resolve immediately

**Code Complexity**:
- Functions should be under 50 lines (prefer 10-30)
- Cyclomatic complexity should stay below 10
- Deeply nested code (>3 levels) indicates need for refactoring

**Dependencies**:
- Audit dependencies regularly - remove unused ones
- Prefer well-maintained, popular crates/packages
- Minimize dependency tree depth

### Scripting Guidelines

**Bash Scripts**:
- Use bash for simple automation (< 100 lines)
- Use shellcheck for validation
- Always use `set -euo pipefail` at the start
- Quote all variables: `"${var}"` not `$var`

**When to Switch to Python**:
- Script exceeds 100 lines
- Complex data structures needed
- JSON/YAML parsing required
- Cross-platform compatibility needed
- Error handling becomes complex

**Python Scripts**:
- Use type hints even in scripts
- Include `#!/usr/bin/env python3` shebang
- Use `argparse` for CLI arguments
- Keep scripts focused - one purpose per script

---
## 3. Continuous Improvement

Actively integrate learning from previous mistakes into the proactive development cycle to prevent recurring errors:

### Build and Test Failures
- Document all encountered build and test failures with specific causes.
- Regularly review failure logs and integrate solutions into the standard development workflow proactively.
- Maintain a growing reference of common issues and their resolutions for quick reference.

### Linting and Static Analysis
- Track common linting warnings and static analysis issues encountered historically.
- Proactively avoid patterns that have caused past warnings, incorporating this knowledge into the code generation and review phases.

### Process Documentation Updates
- Immediately update process documentation whenever you encounter and solve recurring build, test, or lint issues.
- Clearly specify new guidelines or modifications to existing ones to eliminate similar future problems.
- Use precise examples from historical failures to illustrate improved practices clearly.

---
## 4. Playwright MCP Server Setup and Usage

### Overview

Playwright MCP (Model Context Protocol) is a server that provides browser automation capabilities to AI coding assistants. It enables interaction with web pages through structured accessibility snapshots, bypassing the need for screenshots or visually-tuned models.

### Key Benefits
- **Accessibility-tree based**: Uses Playwright's accessibility tree instead of pixel-based input
- **Deterministic execution**: Avoids ambiguity common with screenshot-based approaches
- **No vision models required**: Operates purely on structured data
- **Cross-platform support**: Works with multiple AI coding assistants through standardized MCP protocol

### Installation Instructions

#### For Claude Code
```bash
# User-level installation (recommended - available across all projects)
claude mcp add playwright -s user -- npx -y @playwright/mcp

# Verify installation
claude mcp list
```

#### For Gemini CLI
```bash
# Ensure Node.js v20+ is installed
# Configure Playwright MCP server
npx @playwright/mcp@latest
```

#### For OpenCode
Configure in the MCP settings file:
```json
{
  "mcpServers": {
    "playwright": {
      "type": "stdio",
      "command": "npx",
      "args": ["@playwright/mcp"],
      "env": []
    }
  }
}
```

### Tool Naming Convention
All Playwright MCP tools follow a consistent naming pattern:
- Claude Code: `mcp__playwright__[action]`
- Other clients may use different prefixes based on their MCP implementation

### Available Tools
- **Navigation**: Navigate to URLs, go back/forward in history
- **Interaction**: Click elements, fill forms, select options, drag and drop
- **State Management**: Handle dialogs, evaluate JavaScript, manage tabs
- **Inspection**: Take screenshots, capture accessibility snapshots, view console logs
- **Waiting**: Wait for specific elements or conditions

### Best Practices
1. **Use User-Level Setup**: Configure frequently-used MCP servers at user level for consistency
2. **Project-Level for Specific Needs**: Use project-level configuration only for project-specific tools
3. **Regular Updates**: Periodically update the MCP server to get latest features
4. **Consistent Naming**: Always use "playwright" as the server name for consistency

### Troubleshooting

#### Browser Installation
If you encounter browser-related errors:
```bash
# Install Chromium (recommended)
npx playwright install chromium

# Or install all browsers
npx playwright install
```

#### Verification
After setup, verify the connection:
```bash
# For Claude Code
claude
> /mcp

# Should show: playwright: npx -y @playwright/mcp - âœ“ Connected
```

---
## Project-Specific Guidelines

### Rust Development
- Use `cargo build` to compile the project
- Use `cargo test` to run all tests
- Use `cargo clippy --all-targets --all-features -- -D warnings` for strict linting
- Use `cargo fmt` for code formatting
- Use `cargo doc --open` to generate and view documentation
- Follow Rust naming conventions (snake_case for functions/variables, CamelCase for types)
- Ensure all public items have documentation comments
- Use Rust 2024 edition features where applicable
- Prefer `let-else` patterns for error handling where appropriate
- Use workspace dependencies for multi-crate projects

### Rust/WASM Projects
- Keep JavaScript to absolute minimum - only for WASM loading
- All business logic must be in Rust
- Use `wasm-bindgen` for JS interop
- Use `wasm-pack` for building and packaging
- Write tests in Rust using `wasm-bindgen-test`, not in JavaScript
- Use `web-sys` for DOM manipulation from Rust
- Minimize JS bundle size - let Rust handle the complexity

---

## Summary of Expected Proactive Behaviors

- Always anticipate checkpoints and proactively align code with defined processes.
- Prioritize incremental, clean commits with immediate pushes to maintain transparency and availability.
- Document thoroughly, test rigorously, format consistently, and manage version control meticulously.
- Continuously adapt and integrate historical lessons into proactive workflow adjustments to minimize repetitive errors.
- Utilize MCP servers like Playwright for enhanced capabilities when working with web automation tasks.

By diligently following these guidelines, AI coding agents will significantly enhance development efficiency, maintainability, and overall code quality.

---

*Generated by Proact - AI Coding Agent Documentation Generator*